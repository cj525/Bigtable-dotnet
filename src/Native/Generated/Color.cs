// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/type/color.proto
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Google.Type {

  namespace Proto {

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public static partial class Color {

      #region Descriptor
      public static pbr::FileDescriptor Descriptor {
        get { return descriptor; }
      }
      private static pbr::FileDescriptor descriptor;

      static Color() {
        byte[] descriptorData = global::System.Convert.FromBase64String(
            string.Concat(
              "Chdnb29nbGUvdHlwZS9jb2xvci5wcm90bxILZ29vZ2xlLnR5cGUaHmdvb2ds", 
              "ZS9wcm90b2J1Zi93cmFwcGVycy5wcm90byJdCgVDb2xvchILCgNyZWQYASAB", 
              "KAISDQoFZ3JlZW4YAiABKAISDAoEYmx1ZRgDIAEoAhIqCgVhbHBoYRgEIAEo", 
              "CzIbLmdvb2dsZS5wcm90b2J1Zi5GbG9hdFZhbHVlQh8KD2NvbS5nb29nbGUu", 
              "dHlwZUIKQ29sb3JQcm90b1ABYgZwcm90bzM="));
        descriptor = pbr::FileDescriptor.InternalBuildGeneratedFileFrom(descriptorData,
            new pbr::FileDescriptor[] { global::Google.Protobuf.Wrappers.Descriptor, },
            new pbr::GeneratedCodeInfo(null, new pbr::GeneratedCodeInfo[] {
              new pbr::GeneratedCodeInfo(typeof(global::Google.Type.Color), new[]{ "Red", "Green", "Blue", "Alpha" }, null, null, null)
            }));
      }
      #endregion

    }
  }
  #region Messages
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Color : pb::IMessage<Color> {
    private static readonly pb::MessageParser<Color> _parser = new pb::MessageParser<Color>(() => new Color());
    public static pb::MessageParser<Color> Parser { get { return _parser; } }

    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Type.Proto.Color.Descriptor.MessageTypes[0]; }
    }

    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    public Color() {
      OnConstruction();
    }

    partial void OnConstruction();

    public Color(Color other) : this() {
      red_ = other.red_;
      green_ = other.green_;
      blue_ = other.blue_;
      Alpha = other.Alpha;
    }

    public Color Clone() {
      return new Color(this);
    }

    public const int RedFieldNumber = 1;
    private float red_;
    public float Red {
      get { return red_; }
      set {
        red_ = value;
      }
    }

    public const int GreenFieldNumber = 2;
    private float green_;
    public float Green {
      get { return green_; }
      set {
        green_ = value;
      }
    }

    public const int BlueFieldNumber = 3;
    private float blue_;
    public float Blue {
      get { return blue_; }
      set {
        blue_ = value;
      }
    }

    public const int AlphaFieldNumber = 4;
    private static readonly pb::FieldCodec<float?> _single_alpha_codec = pb::FieldCodec.ForStructWrapper<float>(34);
    private float? alpha_;
    public float? Alpha {
      get { return alpha_; }
      set {
        alpha_ = value;
      }
    }

    public override bool Equals(object other) {
      return Equals(other as Color);
    }

    public bool Equals(Color other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Red != other.Red) return false;
      if (Green != other.Green) return false;
      if (Blue != other.Blue) return false;
      if (Alpha != other.Alpha) return false;
      return true;
    }

    public override int GetHashCode() {
      int hash = 1;
      if (Red != 0F) hash ^= Red.GetHashCode();
      if (Green != 0F) hash ^= Green.GetHashCode();
      if (Blue != 0F) hash ^= Blue.GetHashCode();
      if (alpha_ != null) hash ^= Alpha.GetHashCode();
      return hash;
    }

    public override string ToString() {
      return pb::JsonFormatter.Default.Format(this);
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (Red != 0F) {
        output.WriteRawTag(13);
        output.WriteFloat(Red);
      }
      if (Green != 0F) {
        output.WriteRawTag(21);
        output.WriteFloat(Green);
      }
      if (Blue != 0F) {
        output.WriteRawTag(29);
        output.WriteFloat(Blue);
      }
      if (alpha_ != null) {
        _single_alpha_codec.WriteTagAndValue(output, Alpha);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (Red != 0F) {
        size += 1 + 4;
      }
      if (Green != 0F) {
        size += 1 + 4;
      }
      if (Blue != 0F) {
        size += 1 + 4;
      }
      if (alpha_ != null) {
        size += _single_alpha_codec.CalculateSizeWithTag(Alpha);
      }
      return size;
    }

    public void MergeFrom(Color other) {
      if (other == null) {
        return;
      }
      if (other.Red != 0F) {
        Red = other.Red;
      }
      if (other.Green != 0F) {
        Green = other.Green;
      }
      if (other.Blue != 0F) {
        Blue = other.Blue;
      }
      if (other.alpha_ != null) {
        if (alpha_ == null || other.Alpha != 0F) {
          Alpha = other.Alpha;
        }
      }
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 13: {
            Red = input.ReadFloat();
            break;
          }
          case 21: {
            Green = input.ReadFloat();
            break;
          }
          case 29: {
            Blue = input.ReadFloat();
            break;
          }
          case 34: {
            float? value = _single_alpha_codec.Read(input);
            if (alpha_ == null || value != 0F) {
              Alpha = value;
            }
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
